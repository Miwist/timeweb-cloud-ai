{"version":3,"sources":["../src/completion-response.ts","../src/agent-instance.ts","../src/client.ts"],"sourcesContent":["import { ChatCompletionResponse } from \"./types.js\";\n\nexport class TimewebChatCompletion {\n  constructor(private readonly rawResponse: ChatCompletionResponse) {}\n\n  /** Возвращает основной текст ответа */\n  get text(): string {\n    return this.rawResponse.choices[0]?.message?.content?.trim() || \"\";\n  }\n\n  /** Возвращает весь исходный ответ (для продвинутых сценариев) */\n  get raw(): ChatCompletionResponse {\n    return this.rawResponse;\n  }\n\n  /** Возвращает количество использованных токенов */\n  get usage() {\n    return this.rawResponse.usage;\n  }\n}\n","// agent-instance.ts\n\nimport { TimewebCloudAIClient } from \"./client.js\";\nimport {\n  AgentResponse,\n  CallAgentRequest,\n  ChatCompletionRequest,\n} from \"./types.js\";\nimport { TimewebChatCompletion } from \"./completion-response.js\";\nimport { readFileSync } from \"fs\";\nimport { Buffer } from \"buffer\";\n\nexport class AgentInstance {\n  constructor(\n    private readonly client: TimewebCloudAIClient,\n    public readonly agent_access_id: string\n  ) {}\n\n  /**\n   * Вызывает агента через упрощённый endpoint `/call`.\n   */\n  call(payload: CallAgentRequest): Promise<AgentResponse> {\n    return this.client.call(this.agent_access_id, payload);\n  }\n\n  /**\n   * OpenAI-совместимый чат. Возвращает удобную обёртку над ответом.\n   */\n  chatCompletions(\n    payload: ChatCompletionRequest\n  ): Promise<TimewebChatCompletion> {\n    return this.client\n      .chatCompletions(this.agent_access_id, payload)\n      .then((raw) => new TimewebChatCompletion(raw));\n  }\n\n  /**\n   * Получает список моделей, доступных для этого агента.\n   */\n  getModels(): Promise<{ object: \"list\"; data: Array<{ id: string }> }> {\n    return this.client.getModels(this.agent_access_id);\n  }\n\n  /**\n   * Отправляет запрос с изображением и текстом.\n   * Поддерживает Buffer, base64-строку или путь к файлу.\n   */\n  async chatWithImage(options: {\n    text?: string;\n    image: Buffer | string;\n    mimeType?: \"image/jpeg\" | \"image/png\" | \"image/webp\";\n    max_tokens?: number;\n    temperature?: number;\n  }): Promise<TimewebChatCompletion> {\n    const { text = \"\", image, mimeType, max_tokens, temperature } = options;\n\n    let imageData: string;\n    let detectedMimeType = mimeType;\n\n    if (typeof image === \"string\") {\n      if (image.startsWith(\"data:\") || image.includes(\";base64,\")) {\n        // Уже data URL\n        imageData = image;\n      } else {\n        // Считаем, что это путь к файлу\n        const buffer = readFileSync(image);\n        detectedMimeType ||= this.detectMimeTypeFromBuffer(buffer);\n        imageData = `data:${detectedMimeType};base64,${buffer.toString(\n          \"base64\"\n        )}`;\n      }\n    } else {\n      // Buffer\n      detectedMimeType ||= this.detectMimeTypeFromBuffer(image);\n      imageData = `data:${detectedMimeType};base64,${image.toString(\"base64\")}`;\n    }\n\n    const payload: ChatCompletionRequest = {\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            { type: \"text\", text },\n            { type: \"image_url\", image_url: { url: imageData } },\n          ],\n        },\n      ],\n      max_tokens,\n      temperature,\n    };\n\n    const rawResponse = await this.client.chatCompletions(\n      this.agent_access_id,\n      payload\n    );\n    return new TimewebChatCompletion(rawResponse);\n  }\n\n  /**\n   * Отправляет запрос с аудио (WAV, 16kHz, mono) и текстом.\n   * Ожидается base64-кодированная строка в формате WAV.\n   */\n  async chatWithAudio(options: {\n    text?: string;\n    audio: string;\n    max_tokens?: number;\n    temperature?: number;\n  }): Promise<TimewebChatCompletion> {\n    const {\n      text = \"Расшифруй аудио.\",\n      audio,\n      max_tokens,\n      temperature,\n    } = options;\n\n    const payload: ChatCompletionRequest = {\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            { type: \"text\", text },\n            {\n              type: \"input_audio\",\n              input_audio: { base64Audio: audio, format: \"wav\" },\n            },\n          ],\n        },\n      ],\n      max_tokens,\n      temperature,\n    };\n\n    const rawResponse = await this.client.chatCompletions(\n      this.agent_access_id,\n      payload\n    );\n    return new TimewebChatCompletion(rawResponse);\n  }\n\n  /**\n   * Определяет MIME-тип изображения по сигнатуре буфера.\n   */\n  private detectMimeTypeFromBuffer(buffer: Buffer): \"image/jpeg\" | \"image/png\" {\n    if (buffer[0] === 0xff && buffer[1] === 0xd8) return \"image/jpeg\";\n    if (buffer[0] === 0x89 && buffer.toString(\"ascii\", 0, 4) === \"\\x89PNG\")\n      return \"image/png\";\n    return \"image/jpeg\"; // fallback\n  }\n}\n","import { AgentInstance } from \"./agent-instance.js\";\nimport {\n  TimewebCloudAIClientOptions,\n  RequestOptions,\n  AgentResponse,\n  ChatCompletionRequest,\n  CallAgentRequest,\n  ChatCompletionResponse,\n} from \"./types.js\";\n\n/**\n * Базовый URL API Timeweb Cloud AI.\n * @see https://agent.timeweb.cloud/docs\n */\nconst BASE_URL = \"https://agent.timeweb.cloud/api/v1/cloud-ai\";\n\n/**\n * Кастомная ошибка для API Timeweb Cloud\n */\nexport class TimewebAPIError extends Error {\n  constructor(\n    public readonly status: number,\n    public readonly body: unknown,\n    message: string\n  ) {\n    super(message);\n    this.name = \"TimewebAPIError\";\n  }\n}\n\n/**\n * Основной клиент для работы с Timeweb Cloud AI API.\n *\n * Требует токен доступа и уникальный идентификатор источника (`x-proxy-source`).\n *\n * @example\n * ```ts\n * const client = new TimewebCloudAIClient({\n *   accessToken: 'your_token',\n *   proxySource: 'my-app'\n * });\n *\n * // Или через агент-специфичный интерфейс:\n * const agent = client.agent('agt_xxx');\n * const res = await agent.call({ message: 'Привет!' });\n * ```\n */\nexport class TimewebCloudAIClient {\n  private readonly accessToken: string;\n  private readonly proxySource: string;\n\n  constructor(options: TimewebCloudAIClientOptions) {\n    if (!options.accessToken) {\n      throw new Error(\"accessToken is required\");\n    }\n    if (!options.proxySource) {\n      throw new Error(\"proxySource is required\");\n    }\n    this.accessToken = options.accessToken;\n    this.proxySource = options.proxySource;\n  }\n\n  /**\n   * Внутренний метод для выполнения HTTP-запросов к API.\n   * Не предназначен для прямого использования.\n   */\n  private async request<T>(\n    method: string,\n    path: string,\n    { params, data, agent_access_id }: RequestOptions = {}\n  ): Promise<T> {\n    if (!agent_access_id) {\n      throw new Error(\"agent_access_id is required for all requests\");\n    }\n\n    const url = new URL(`${BASE_URL}/agents/${agent_access_id}${path}`);\n\n    if (params) {\n      Object.entries(params).forEach(([k, v]) => {\n        url.searchParams.set(k, String(v));\n      });\n    }\n\n    const headers: HeadersInit = {\n      Authorization: `Bearer ${this.accessToken}`,\n      \"x-proxy-source\": this.proxySource,\n      \"Content-Type\": \"application/json\",\n    };\n\n    const config: RequestInit = { method, headers };\n    if (data !== undefined) {\n      config.body = JSON.stringify(data);\n    }\n\n    let response: Response;\n    try {\n      response = await fetch(url.toString(), config);\n    } catch (error) {\n      throw new Error(`Network error: ${(error as Error).message}`);\n    }\n\n    let text: string;\n    try {\n      text = await response.text();\n    } catch {\n      throw new Error(\"Failed to read response body\");\n    }\n\n    if (!response.ok) {\n      let jsonBody: unknown;\n      try {\n        jsonBody = text ? JSON.parse(text) : {};\n      } catch {\n        jsonBody = { raw: text };\n      }\n      const message = `Timeweb API error ${response.status}: ${\n        text || \"no response body\"\n      }`;\n      throw new TimewebAPIError(response.status, jsonBody, message);\n    }\n\n    try {\n      return text ? JSON.parse(text) : ({} as T);\n    } catch {\n      throw new Error(\"Invalid JSON response from Timeweb API\");\n    }\n  }\n\n  /**\n   * Вызывает агента с сообщением или файлами.\n   * @param agent_access_id Уникальный ID агента (начинается с `agt_`)\n   * @param payload Объект с сообщением и/или файлами\n   * @returns Ответ от агента\n   */\n  call(\n    agent_access_id: string,\n    payload: CallAgentRequest\n  ): Promise<AgentResponse> {\n    return this.request(\"POST\", \"/call\", { agent_access_id, data: payload });\n  }\n\n  /**\n   * OpenAI-совместимый endpoint для генерации чата.\n   * @param agent_access_id Уникальный ID агента\n   * @param payload Запрос в формате OpenAI Chat Completions\n   * @returns Ответ в формате OpenAI\n   */\n  chatCompletions(\n    agent_access_id: string,\n    payload: ChatCompletionRequest\n  ): Promise<ChatCompletionResponse> {\n    return this.request(\"POST\", \"/v1/chat/completions\", {\n      agent_access_id,\n      data: payload,\n    });\n  }\n\n  /**\n   * Получает список моделей, доступных для агента.\n   * @param agent_access_id Уникальный ID агента\n   * @returns Список моделей\n   */\n  getModels(\n    agent_access_id: string\n  ): Promise<{ object: \"list\"; data: Array<{ id: string }> }> {\n    return this.request(\"GET\", \"/v1/models\", { agent_access_id });\n  }\n\n  /**\n   * ⚠️ Этот метод работает ТОЛЬКО в браузерном окружении.\n   * В Node.js он вызовет ошибку CORS или 403 из-за ограничений безопасности.\n   *\n   * Предназначен для получения JavaScript-кода виджета агента.\n   *\n   * @deprecated Рекомендуется использовать только на фронтенде.\n   */\n  async getEmbedScript(\n    agent_access_id: string,\n    referer_domain: string = \"\",\n    origin_domain: string = \"\",\n    collapsed: boolean = true\n  ): Promise<string> {\n    const url = new URL(`${BASE_URL}/agents/${agent_access_id}/embed.js`);\n    url.searchParams.set(\"collapsed\", String(collapsed));\n\n    const response = await fetch(url.toString(), {\n      headers: {\n        referer: referer_domain,\n        origin: origin_domain,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch embed script (${response.status})`);\n    }\n\n    return await response.text();\n  }\n\n  /**\n   * Создаёт привязанный к конкретному агенту экземпляр для удобной работы\n   * без необходимости передавать `agent_access_id` в каждый вызов.\n   *\n   * @example\n   * ```ts\n   * const client = new TimewebCloudAIClient({ accessToken: '...', proxySource: 'my-app' });\n   * const agent = client.agent('agt_xxx');\n   * const response = await agent.call({ message: 'Привет!' });\n   * ```\n   *\n   * @param agent_access_id Уникальный идентификатор агента (начинается с `agt_`)\n   * @returns Экземпляр {@link AgentInstance}, привязанный к указанному агенту\n   */\n  agent(agent_access_id: string): AgentInstance {\n    return new AgentInstance(this, agent_access_id);\n  }\n}\n"],"mappings":";AAEO,IAAM,wBAAN,MAA4B;AAAA,EACjC,YAA6B,aAAqC;AAArC;AAAA,EAAsC;AAAA;AAAA,EAGnE,IAAI,OAAe;AACjB,WAAO,KAAK,YAAY,QAAQ,CAAC,GAAG,SAAS,SAAS,KAAK,KAAK;AAAA,EAClE;AAAA;AAAA,EAGA,IAAI,MAA8B;AAChC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAGA,IAAI,QAAQ;AACV,WAAO,KAAK,YAAY;AAAA,EAC1B;AACF;;;ACVA,SAAS,oBAAoB;AAGtB,IAAM,gBAAN,MAAoB;AAAA,EACzB,YACmB,QACD,iBAChB;AAFiB;AACD;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAKH,KAAK,SAAmD;AACtD,WAAO,KAAK,OAAO,KAAK,KAAK,iBAAiB,OAAO;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAKA,gBACE,SACgC;AAChC,WAAO,KAAK,OACT,gBAAgB,KAAK,iBAAiB,OAAO,EAC7C,KAAK,CAAC,QAAQ,IAAI,sBAAsB,GAAG,CAAC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,YAAsE;AACpE,WAAO,KAAK,OAAO,UAAU,KAAK,eAAe;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,cAAc,SAMe;AACjC,UAAM,EAAE,OAAO,IAAI,OAAO,UAAU,YAAY,YAAY,IAAI;AAEhE,QAAI;AACJ,QAAI,mBAAmB;AAEvB,QAAI,OAAO,UAAU,UAAU;AAC7B,UAAI,MAAM,WAAW,OAAO,KAAK,MAAM,SAAS,UAAU,GAAG;AAE3D,oBAAY;AAAA,MACd,OAAO;AAEL,cAAM,SAAS,aAAa,KAAK;AACjC,6BAAqB,KAAK,yBAAyB,MAAM;AACzD,oBAAY,QAAQ,gBAAgB,WAAW,OAAO;AAAA,UACpD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,OAAO;AAEL,2BAAqB,KAAK,yBAAyB,KAAK;AACxD,kBAAY,QAAQ,gBAAgB,WAAW,MAAM,SAAS,QAAQ,CAAC;AAAA,IACzE;AAEA,UAAM,UAAiC;AAAA,MACrC,UAAU;AAAA,QACR;AAAA,UACE,MAAM;AAAA,UACN,SAAS;AAAA,YACP,EAAE,MAAM,QAAQ,KAAK;AAAA,YACrB,EAAE,MAAM,aAAa,WAAW,EAAE,KAAK,UAAU,EAAE;AAAA,UACrD;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,cAAc,MAAM,KAAK,OAAO;AAAA,MACpC,KAAK;AAAA,MACL;AAAA,IACF;AACA,WAAO,IAAI,sBAAsB,WAAW;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,cAAc,SAKe;AACjC,UAAM;AAAA,MACJ,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AAEJ,UAAM,UAAiC;AAAA,MACrC,UAAU;AAAA,QACR;AAAA,UACE,MAAM;AAAA,UACN,SAAS;AAAA,YACP,EAAE,MAAM,QAAQ,KAAK;AAAA,YACrB;AAAA,cACE,MAAM;AAAA,cACN,aAAa,EAAE,aAAa,OAAO,QAAQ,MAAM;AAAA,YACnD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,cAAc,MAAM,KAAK,OAAO;AAAA,MACpC,KAAK;AAAA,MACL;AAAA,IACF;AACA,WAAO,IAAI,sBAAsB,WAAW;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,QAA4C;AAC3E,QAAI,OAAO,CAAC,MAAM,OAAQ,OAAO,CAAC,MAAM,IAAM,QAAO;AACrD,QAAI,OAAO,CAAC,MAAM,OAAQ,OAAO,SAAS,SAAS,GAAG,CAAC,MAAM;AAC3D,aAAO;AACT,WAAO;AAAA,EACT;AACF;;;ACtIA,IAAM,WAAW;AAKV,IAAM,kBAAN,cAA8B,MAAM;AAAA,EACzC,YACkB,QACA,MAChB,SACA;AACA,UAAM,OAAO;AAJG;AACA;AAIhB,SAAK,OAAO;AAAA,EACd;AACF;AAmBO,IAAM,uBAAN,MAA2B;AAAA,EACf;AAAA,EACA;AAAA,EAEjB,YAAY,SAAsC;AAChD,QAAI,CAAC,QAAQ,aAAa;AACxB,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AACA,QAAI,CAAC,QAAQ,aAAa;AACxB,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AACA,SAAK,cAAc,QAAQ;AAC3B,SAAK,cAAc,QAAQ;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,QACZ,QACA,MACA,EAAE,QAAQ,MAAM,gBAAgB,IAAoB,CAAC,GACzC;AACZ,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAEA,UAAM,MAAM,IAAI,IAAI,GAAG,QAAQ,WAAW,eAAe,GAAG,IAAI,EAAE;AAElE,QAAI,QAAQ;AACV,aAAO,QAAQ,MAAM,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,MAAM;AACzC,YAAI,aAAa,IAAI,GAAG,OAAO,CAAC,CAAC;AAAA,MACnC,CAAC;AAAA,IACH;AAEA,UAAM,UAAuB;AAAA,MAC3B,eAAe,UAAU,KAAK,WAAW;AAAA,MACzC,kBAAkB,KAAK;AAAA,MACvB,gBAAgB;AAAA,IAClB;AAEA,UAAM,SAAsB,EAAE,QAAQ,QAAQ;AAC9C,QAAI,SAAS,QAAW;AACtB,aAAO,OAAO,KAAK,UAAU,IAAI;AAAA,IACnC;AAEA,QAAI;AACJ,QAAI;AACF,iBAAW,MAAM,MAAM,IAAI,SAAS,GAAG,MAAM;AAAA,IAC/C,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,kBAAmB,MAAgB,OAAO,EAAE;AAAA,IAC9D;AAEA,QAAI;AACJ,QAAI;AACF,aAAO,MAAM,SAAS,KAAK;AAAA,IAC7B,QAAQ;AACN,YAAM,IAAI,MAAM,8BAA8B;AAAA,IAChD;AAEA,QAAI,CAAC,SAAS,IAAI;AAChB,UAAI;AACJ,UAAI;AACF,mBAAW,OAAO,KAAK,MAAM,IAAI,IAAI,CAAC;AAAA,MACxC,QAAQ;AACN,mBAAW,EAAE,KAAK,KAAK;AAAA,MACzB;AACA,YAAM,UAAU,qBAAqB,SAAS,MAAM,KAClD,QAAQ,kBACV;AACA,YAAM,IAAI,gBAAgB,SAAS,QAAQ,UAAU,OAAO;AAAA,IAC9D;AAEA,QAAI;AACF,aAAO,OAAO,KAAK,MAAM,IAAI,IAAK,CAAC;AAAA,IACrC,QAAQ;AACN,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,KACE,iBACA,SACwB;AACxB,WAAO,KAAK,QAAQ,QAAQ,SAAS,EAAE,iBAAiB,MAAM,QAAQ,CAAC;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,gBACE,iBACA,SACiC;AACjC,WAAO,KAAK,QAAQ,QAAQ,wBAAwB;AAAA,MAClD;AAAA,MACA,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UACE,iBAC0D;AAC1D,WAAO,KAAK,QAAQ,OAAO,cAAc,EAAE,gBAAgB,CAAC;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,eACJ,iBACA,iBAAyB,IACzB,gBAAwB,IACxB,YAAqB,MACJ;AACjB,UAAM,MAAM,IAAI,IAAI,GAAG,QAAQ,WAAW,eAAe,WAAW;AACpE,QAAI,aAAa,IAAI,aAAa,OAAO,SAAS,CAAC;AAEnD,UAAM,WAAW,MAAM,MAAM,IAAI,SAAS,GAAG;AAAA,MAC3C,SAAS;AAAA,QACP,SAAS;AAAA,QACT,QAAQ;AAAA,MACV;AAAA,IACF,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI,MAAM,iCAAiC,SAAS,MAAM,GAAG;AAAA,IACrE;AAEA,WAAO,MAAM,SAAS,KAAK;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,MAAM,iBAAwC;AAC5C,WAAO,IAAI,cAAc,MAAM,eAAe;AAAA,EAChD;AACF;","names":[]}